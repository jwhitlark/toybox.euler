(ns euler.problem45
    (:require [clojure.reflect :as r]
            [clojure.java.io :as io]
            [clojure.set :as set]
            [clojure.string :as str]
            [clojure.pprint :as pp]
            [clojure.edn :as edn]
            [clojure.test :as test]
            [clojure.repl :refer [doc source dir]]

            [clojure.math.combinatorics :as combo]

            [criterium.core :as crit]
            [clj-http.client :as http]

            [clojure.inspector :refer [inspect inspect-table inspect-tree]]
            [clojure.tools.namespace.repl :refer [refresh refresh-all]]

            [flatland.useful.debug :refer [?]]
            [flatland.useful.map :refer [merge-in]]
            [flatland.useful.fn :refer [! validator as-fn thrush applied]]
            [flatland.useful.seq :as seq]
            [flatland.useful.utils :refer [verify returning pop-if queue let-later empty-coll? with-timing]]

            ;; [multiset.core :as mset]
            [clojure.math.numeric-tower :as clj-math]
            [euler.common :refer :all]
            ))

"Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:

Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Pentagonal	 	Pn=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...
It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal."

;; Are these Diophantine equations?

;; Turns out that all hexagonal-numbers are triangular, so you only
;; need two of the sets below. But I didn't figure that out, so it's
;; still in here.

(defn solve [mx]
  (time (let [tr (set (map triangle-number (range 1 mx)))
              pn (set (map pentagonal-number (range 1 mx)))
              hx (set (map hexagonal-number (range 1 mx)))]
          (take 3 (set/intersection tr pn hx)))))

;; euler.problem45> (solve 1e5)
;; "Elapsed time: 200.711 msecs"
;; #{1 40755 1533776805}

;; -------------------- Code below off forum. much faster. :-/

(defn pentagonals
  "Generate an infinite lazy sequence of pentagonal numbers"
  []
  (map #(/ (* % (- (* 3 %) 1)) 2) (iterate inc 1)))

(defn hexal?
  "Check for hexagonality"
  [n]
  (let [res (/ (+ 1 (Math/sqrt (+ 1 (* 8 n)))) 4)]
    (== (int res) res)))


(defn euler45
  [n]
  (->> (pentagonals)
       (filter hexal?)
       (take n)
       time))

;; euler.problem45> (euler45 3)
;; "Elapsed time: 0.004 msecs"
;; (1 40755 1533776805)
